/*
 * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

import java.io.IOException;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.regex.MatchResult;

/*
 * An enhanced dummy LDAP server which can playback captured LDAP messages.
 *
 * Loads a sequence of LDAP messages from a capture file into its cache.
 * It listens for LDAP requests, finds a match in its cache and sends the
 * corresponding LDAP responses.
 *
 * The capture file contains an LDAP protocol exchange in the hexadecimal
 * dump format emitted by sun.misc.HexDumpEncoder:
 *
 * xxxx: 00 11 22 33 44 55 66 77   88 99 aa bb cc dd ee ff  ................
 *
 * Typically, LDAP protocol exchange is generated by running the LDAP client
 * application program against a real LDAP server and setting the JNDI/LDAP
 * environment property: com.sun.jndi.ldap.trace.ber to activate LDAP message
 * tracing.
 */
public class LdapPlaybackServer extends BaseLdapServer {

    /*
     * A cache of LDAP requests and responses.
     * Messages with the same ID are stored in a list.
     * The first element in the list is the LDAP request,
     * the remaining elements are the LDAP responses.
     */
    private final Map<Integer, List<byte[]>> cache = new HashMap<>();

    private String fileName;

    public LdapPlaybackServer(ServerSocket serverSocket, String fileName) {
        super(serverSocket);
        this.fileName = fileName;
        setDebugLevel(DebugLevel.CUSTOMIZE, this.getClass());
        setCommonRequestHandler(this::handleRequest);
    }

    /*
     * Load a capture file containing an LDAP protocol exchange in the
     * hexadecimal dump format emitted by sun.misc.HexDumpEncoder:
     *
     * xxxx: 00 11 22 33 44 55 66 77   88 99 aa bb cc dd ee ff  ................
     */
    private void loadCaptureFile(String filename) throws IOException {
        StringBuilder hexString = new StringBuilder();
        String pattern = "(....): (..) (..) (..) (..) (..) (..) (..) (..)   (..) (..) (..) (..) (..) (..) (..) (..).*";
        String preLineNum = "";

        try (Scanner fileScanner = new Scanner(Paths.get(filename))) {
            while (fileScanner.hasNextLine()) {

                try (Scanner lineScanner = new Scanner(
                        fileScanner.nextLine())) {
                    if (lineScanner.findInLine(pattern) == null) {
                        preLineNum = "";
                        continue;
                    }
                    MatchResult result = lineScanner.match();
                    for (int i = 1; i <= result.groupCount(); i++) {
                        String digits = result.group(i);
                        if (digits.length() == 4) {
                            if (digits.equals("0000") && !preLineNum
                                    .equalsIgnoreCase(
                                            "FFF0")) { // start-of-message
                                if (hexString.length() > 0) {
                                    addToCache(hexString.toString());
                                    hexString = new StringBuilder();
                                }
                            }
                            preLineNum = digits;
                            continue;
                        } else if (digits.equals("  ")) { // short message
                            continue;
                        }
                        hexString.append(digits);
                    }
                }
            }
        }
        if (!hexString.toString().isEmpty()) {
            addToCache(hexString.toString());
        }
    }

    /*
     * Add an LDAP encoding to the cache (by messageID key).
     */
    private void addToCache(String hexString) {
        LdapMessage message = new LdapMessage(hexString);
        byte[] encoding = message.getMessages();
        int messageID = message.getMessageID();
        List<byte[]> encodings = cache.get(messageID);
        if (encodings == null) {
            encodings = new ArrayList<>();
        }
        debug("    adding LDAP " + message.getOperation() + " with message ID "
                + messageID + " to the cache");
        encodings.add(encoding);
        cache.put(messageID, encodings);
    }

    @Override
    public void stopServer() {
        debug("force stopping server");
        super.stopServer();
    }

    private void handleRequest(LdapMessage request, OutputStream out)
            throws IOException {
        int messageID = request.getMessageID();
        debug("received LDAP " + request.getOperation() + "  [message ID "
                + messageID + "]");

        List<byte[]> encodings = cache.get(messageID);
        if (encodings == null || (!Arrays
                .equals(request.getMessages(), encodings.get(0)))) {
            throw new RuntimeException(
                    "LDAPServer: ERROR: received an LDAP " + request
                            .getOperation() + " (ID=" + messageID
                            + ") not present in cache");
        }

        for (int i = 1; i < encodings.size(); i++) {
            // skip the request (at index 0)
            byte[] response = encodings.get(i);
            out.write(response, 0, response.length);
            LdapMessage responseMsg = new LdapMessage(response);
            debug("Sent LDAP " + responseMsg.getOperation() + "  [message ID "
                    + responseMsg.getMessageID() + "]");
        }
    }

    @Override
    public void run() {
        try {
            debug("Loading LDAP cache from: " + fileName);
            loadCaptureFile(fileName);
            debug("listening on port " + getPort());

            super.run();
        } catch (Exception e) {
            debug("ERROR: " + e);
            e.printStackTrace();
        }
    }
}
